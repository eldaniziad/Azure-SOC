## Introduction

In this project, I design and deployed a honeynet within the Azure platform, with the objective of demonstrating best security practices and incident response strategies while assessing the impact of environment hardening on security metrics. The project involved the collection of log sources from diverse origins, which were consolidated into a **Log Analytics workspace**. This workspace formed the foundation for **Microsoft Sentinel's** operations, facilitating the construction of attack maps, the triggering of alerts, and the generation of incidents.

The honeynet was initially set up in a vulnerable state, open to internet traffic, to attract potential attackers and simulate real-world threats. This setup enabled the capture and analysis of security metrics over a 24-hour period, providing a baseline for the insecure environment. Following this, I implemented targeted security controls aimed at protecting the environment, after which I conducted a second round of metric measurement over another 24-hour period to evaluate the effectiveness of these controls.

Additionally, the project incorporated **Microsoft Defender for Cloud** to assess virtual machine configurations and align them with regulatory frameworks and security controls. A critical part of this phase involved addressing incidents identified by Microsoft Sentinel and applying recommendations from Microsoft Defender to enhance security.

The metrics collected and analyzed in this project include:

1. **SecurityEvent**: Windows Event Logs, providing insights into security-related events within the Windows operating system.
2. **Syslog**: Linux Event Logs, offering a view into security events occurring within Linux systems.
3. **SecurityAlert**: Alerts triggered in Log Analytics, highlighting potential security issues detected in the environment.
4. **SecurityIncident**: Incidents generated by Microsoft Sentinel, reflecting significant security events requiring investigation and response.
5. **AzureNetworkAnalytics_CL**: Identified malicious network flows permitted into our honeynet, tracking unauthorized or suspicious network traffic.

This project offers valuable insights into the scope of cyber threats and defense mechanisms but also serves as a case study for the effective use of Azure and Microsoft Sentinel in creating and managing a secure and resilient digital environment.

### Objective

The central goal of this project was to establish a network of intentionally vulnerable virtual machines within the Azure infrastructure. This approach served two primary objectives. Firstly, it functioned as a honeypot strategy to attract and analyze cyber attacks. By deliberately introducing vulnerabilities, these virtual machines became enticing targets for attackers, creating an opportunity to study their tactics and techniques in a controlled environment. This aspect of the project was crucial for gaining a deeper understanding of the nature and methodology of cyber threats.

Secondly, the project served as a platform to demonstrate my skills and proficiency in responding to security incidents. The setup allowed me to monitor, detect, and react to cyber attacks in real-time. This hands-on experience was helpful for developing my ability to identify and address security vulnerabilities and breaches effectively and efficiently.

### Technologies, Azure Components, and Regulations Employed

- Azure Virtual Network (VNet)
- Azure Network Security Group (NSG)
- Virtual Machines (2x Windows, 1x Linux)
- Azure Storage Account for Data Storage
- Log Analytics Workspace with Kusto Query Language (KQL) Queries
- Azure Key Vault for Secure Secrets Management
- Windows Remote Desktop for Remote Access
- Installed SQL Server on the Virtual Machine
- Command Line Interface (CLI) for System Management
- NIST SP 800-61 Revision 2 for Incident Handling Guidance
- Microsoft Defender for Cloud to Protect Cloud Resources
- Microsoft Sentinel for Security Information and Event Management (SIEM)
- Windows Event Viewer
- PowerShell for Automation and Configuration Management
- **NIST SP 800-53 Revision 5** for Security Controls
- **NIST SP 800-61 Revision 2** for Incident Handling Guidance

---
# Process and Methodology

In this cybersecurity project, the process and methodology encompassed distinct phases, each designed to systematically analyze and improve the security posture of a virtual environment in Microsoft Azure. Here's an overview of each phase:

### **Phase I - Creating The Honeynet**

- The project started with the deployment of multiple vulnerable virtual machines in Azure, simulating an insecure environment that attracts cyber attackers.

### **Phase II - Simulated Attacks & Logging and Monitoring**

- Simulated attacks were created to manually trigger events, including brute force attempts and malware injections. This phase also involved using KQL queries to analyze triggered events and alerts from both simulated and actual attacks.

    <details>
      <summary>SQL Brute Force</summary>
      
      $serverName = "20.242.43.183" # Replace with the name of your SQL Server instance
      $databaseName = "master" # Replace with the name of your database
      $username = "cyber-lab-fake-user" # This is the username to attempt a login with (you can change this)
      $password = "__obvious_bad_password_to_generate_auth_failures__"
      $max_attempts = 30 #
      
      # Build the connection string using Windows authentication. You don't have to touch this
      $connectionString = "Server=$serverName;Database=$databaseName;Integrated Security=False;User Id=$username;Password=$password;"
      
      $count = 0
      
      while ($count -lt $max_attempts){
          $count++
          try {
              # Pause the script for 2 seconds to allow for processing
              Start-Sleep -Seconds 3
      
              # Open the connection
              $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
              $connection.Open()
          
              # Define the SQL query to execute
              $query = "SELECT * FROM spt_monitor"
          
              # Create a command object and execute the query
              $command = New-Object System.Data.SqlClient.SqlCommand($query, $connection)
              $result = $command.ExecuteReader()
          
              # Process the query results
              while ($result.Read()) {
                  Write-Host $result
              }
          
          } catch {
              # Handle any errors that occur
              Write-Host "Error: $($Error[0].Exception.Message)"
          } finally {
              # Close the connection
              if ($connection.State -eq "Open") {
                  $connection.Close()
              }
          }
      }
      
    </details>

    <details>
      <summary>Windows Brute Force Success</summary>

      # This script fails to login '$max_attempts' times, and then successfully logs in once
      
      # Authenticate user against Azure AD
      $tenantId = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" # Your Tenant ID, you can find on the AAD Blade in the Azure Portal
      $username = "attacker@joshmadakorgmail.onmicrosoft.com" # Some Username that exists in your AAD Tenant
      $correct_password = "Cyberlab123!" # Enter the correct password for the above user
      $wrong_password = "___WRONG PASSWORD___" # This is used to generate auth failures
      $max_attempts = 11 # This is the number of times to fail the login before succeeding
      
      # Disconnect from AAD if already connected; we want to try to authenticate
      if ((Get-AzContext) -eq $true) {
          Disconnect-AzAccount
      }
      
      # This section will fail 11 logon attempts against Azure AD
      $count = 0
      
      while ($count -le $max_attempts) {
          Start-Sleep -Seconds 1
          $count++
          try {
              $securePassword = ConvertTo-SecureString $wrong_password -AsPlainText -Force
              $cred = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
              Connect-AzAccount -TenantId $tenantId -Credential $cred -ErrorAction SilentlyContinue
          }
          catch {
              Write-Host "Login Failure. $($count))"
              # $Error[0].Exception.Message # Remove the Hash (#) before $Error if you want to see the error message
          }
      }
      
      # This section will (should) successfully authenticate against AAD, simulating a successful brute force attack
      $securePassword = ConvertTo-SecureString $correct_password -AsPlainText -Force
      $cred = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
      Connect-AzAccount -TenantId $tenantId -Credential $cred -ErrorAction SilentlyContinue
      
    </details>

    <details>
      <summary>Malware Detection (EICAR Test File)</summary>

      $TOTAL_VIRUSES_TO_MAKE = 1
      
      $firsthalf = 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR'
      $secondhalf = '-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
      
      $count = 0
      
      while ($count -lt $TOTAL_VIRUSES_TO_MAKE) {
      
          Write-Host "Generating: EICAR-$($count).txt"
          "$($firsthalf)$($secondhalf)" | Out-File -FilePath "EICAR-$($count).txt"
          $count++
      }
      
    </details>

    <details>
      <summary>Privilege Escalation</summary>
      
      <!-- Insert your privilege escalation code here -->
      
    </details>
    <details>
      <summary>AAD Brute Force Success</summary>
      
      <!-- Insert your AAD Brute Force Success code here -->
      
    </details>
    
### **Phase III - Analysis & Incident Assessment and Response**

- A thorough assessment of incidents generated during the 24-hour insecure environment operation was conducted. This included analyzing the entities responsible for attacks, their tactics, techniques, types of attacks, and timelines.

### **Phase IV - Remediation & Regulatory Compliance Implementation**

- Post-analysis, security controls were implemented to secure the environment. This involved disabling public access, creating private endpoints, establishing additional network security groups, and configuring NSG rules. These measures were aligned with NIST 800-53 regulatory compliance standards, emphasizing access control and system integrity.

### **Phase V - Results & Metrics Comparison**

- The final phase involved measuring and recording results and metrics from both insecure and secure environments to evaluate the effectiveness of the implemented security controls.

---

# **Architecture BEFORE Hardening and Implementing Security Controls**

In the "BEFORE" stage of the project, I purposefully deployed resources without any security hardening to create a deliberately insecure environment, aimed at attracting potential cyber attackers for the purpose of analyzing their methods. During this phase:

1. **Public Exposure**: All resources, including Virtual Machines (VMs), storage accounts, and databases, were deployed with direct public exposure to the internet, making them accessible from any external source without restrictions.
2. **Network Security Groups (NSGs) and Firewalls**: The VMs were configured with their Network Security Groups (NSGs) and built-in firewalls set to allow all incoming and outgoing traffic, thereby providing an open gateway for potential attackers.
3. **Public Endpoints**: I deployed other resources with publicly visible endpoints, intentionally refraining from using Private Endpoints which offer a more secure and isolated connection.

This approach was designed to actively engage with and study cyber attack patterns, techniques, and their effects on the intentionally vulnerable environment, providing valuable insights into the types of vulnerabilities and risks present in such an exposed setup.

<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/9ed72be8-4ed9-4f86-9121-fd4de0c6a985" alt="before controls" width="500" height="auto">
</div>

### Attack Maps Before Hardening / Security Controls

***NOTE:** The attack maps were generated by extracting data from a workbook utilizing pre-built [KQL .JSON](https://github.com/AmiliaSalva/Cloud-SOC-Project-Resources/blob/main/MS%20Sentinel%20Maps%20(JSON)/linux-ssh-auth-fail.json) map files. These files provided a structured representation of the attack patterns and their associated data, enabling the creation of visualizations that effectively illustrated the cyber threats and their impact on the system.*

**Linux SSH Authentication Failures**
<br/>This attack map shows all the attempts threat actors trying to access the Linux virtual machine via SSH
<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/1e41ed25-f3b6-4973-94b7-0ea2b0ff4464" alt="before controls" width="500" height="auto">
</div>
  <details>
    <summary>JSON</summary>

    {
    "type": 3,
    "content": {
      "version": "KqlItem/1.0",
      "query": "let GeoIPDB = _GetWatchlist(\"geo_ipv4\");\nlet GeoIPDB_cities = _GetWatchlist(\"geo_ipv4_cities\");\nlet GeoIPDB_FULL = GeoIPDB | join kind = leftouter GeoIPDB_cities on geoname_id;\nlet IpAddress_REGEX_PATTERN = @\"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b\";\nSyslog\n| where Facility == \"auth\"\n| where SyslogMessage startswith \"Failed password for\"\n| order by TimeGenerated desc\n| project TimeGenerated, SourceIP = extract(IpAddress_REGEX_PATTERN, 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type\n| evaluate ipv4_lookup(GeoIPDB_FULL, SourceIP, network)\n| project TimeGenerated, SourceIP, DestinationHostName, DestinationIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type, latitude, longitude, subdivision = subdivision_1_name, city = city_name, country = country_name, friendly_location = strcat(city_name, \" (\", country_name, \")\");",
      "size": 3,
      "timeContext": {
        "durationMs": 2592000000
      },
      "queryType": 0,
      "resourceType": "microsoft.operationalinsights/workspaces",
      "visualization": "map",
      "mapSettings": {
        "locInfo": "LatLong",
        "locInfoColumn": "country_name",
        "latitude": "latitude",
        "longitude": "longitude",
        "sizeSettings": "latitude",
        "sizeAggregation": "Count",
        "opacity": 0.8,
        "labelSettings": "friendly_location",
        "legendMetric": "friendly_location",
        "legendAggregation": "Count",
        "itemColorSettings": {
          "nodeColorField": "latitude",
          "colorAggregation": "Count",
          "type": "heatmap",
          "heatmapPalette": "greenRed"
        }
      }
    },
    "name": "query - 0"
    }
    
  </details>

**Windows RDP/SMB Authentication Failures**
<br/>This attack map shows all the attempts threat actors trying to access the Windows virtual machine via RDP
<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/bc915a71-5540-4d72-9949-d453386dbaef" alt="before controls" width="500" height="auto">
</div>
  <details>
    <summary>JSON</summary>

    {
    "type": 3,
    "content": {
      "version": "KqlItem/1.0",
      "query": "let GeoIPDB = _GetWatchlist(\"geo_ipv4\");\nlet GeoIPDB_cities = _GetWatchlist(\"geo_ipv4_cities\");\nlet GeoIPDB_FULL = GeoIPDB | join kind = leftouter GeoIPDB_cities on geoname_id;\nlet WindowsEvents = SecurityEvent;\nWindowsEvents | where EventID == 4625\n| order by TimeGenerated desc\n| evaluate ipv4_lookup(GeoIPDB_FULL, IpAddress, network)\n| project TimeGenerated, Account, AccountType, Computer, EventID, Activity, IpAddress, LogonTypeName, network, latitude, longitude, subdivision = subdivision_1_name, city = city_name, country = country_name, friendly_location = strcat(city_name, \" (\", country_name, \")\");\n",
      "size": 3,
      "timeContext": {
        "durationMs": 2592000000
      },
      "queryType": 0,
      "resourceType": "microsoft.operationalinsights/workspaces",
      "visualization": "map",
      "mapSettings": {
        "locInfo": "LatLong",
        "locInfoColumn": "country_name",
        "latitude": "latitude",
        "longitude": "longitude",
        "sizeSettings": "EventID",
        "sizeAggregation": "Count",
        "opacity": 0.8,
        "labelSettings": "friendly_location",
        "legendMetric": "EventID",
        "legendAggregation": "Count",
        "itemColorSettings": {
          "nodeColorField": "EventID",
          "colorAggregation": "Sum",
          "type": "heatmap",
          "heatmapPalette": "greenRed"
        }
      }
    },
    "name": "query - 0"
    }
    
  </details>

**MS SQL Server Authentication Failures**
<br/>This attack map shows all the attempts threat actors trying to access the Microsoft SQL Database Server within the Windows virtual machine
<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/23cbf510-93ef-437a-9359-a90292e15f86" alt="before controls" width="500" height="auto">
</div>
  <details>
    <summary>JSON</summary>

    {
    "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let GeoIPDB = _GetWatchlist(\"geo_ipv4\");\nlet GeoIPDB_cities = _GetWatchlist(\"geo_ipv4_cities\");\nlet GeoIPDB_FULL = GeoIPDB | join kind = leftouter GeoIPDB_cities on geoname_id;\nlet IpAddress_REGEX_PATTERN = @\"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b\";\n// Brute Force Attempt MS SQL Server\nEvent\n| where EventLog == \"Application\"\n| where EventID == 18456\n| project TimeGenerated, AttackerIP = extract(IpAddress_REGEX_PATTERN, 0, RenderedDescription), DestinationHostName = Computer, RenderedDescription\n| evaluate ipv4_lookup(GeoIPDB_FULL, AttackerIP, network)\n| project TimeGenerated, AttackerIP, DestinationHostName, RenderedDescription, latitude, longitude, subdivision = subdivision_1_name, city = city_name, country = country_name, friendly_location = strcat(city_name, \" (\", country_name, \")\");",
        "size": 3,
        "timeContext": {
          "durationMs": 2592000000
        },
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces",
        "visualization": "map",
        "mapSettings": {
          "locInfo": "LatLong",
          "locInfoColumn": "country_name",
          "latitude": "latitude",
          "longitude": "longitude",
          "sizeSettings": "latitude",
          "sizeAggregation": "Count",
          "opacity": 0.8,
          "labelSettings": "friendly_location",
          "legendMetric": "friendly_location",
          "legendAggregation": "Count",
          "itemColorSettings": {
            "nodeColorField": "latitude",
            "colorAggregation": "Sum",
            "type": "heatmap",
            "heatmapPalette": "greenRed"
          }
        }
      },
      "name": "query - 0
    }
    
  </details>

**NSG Allowed Malicious Inbound Flows**
<br/>This attack map shows the traffic allowed by a Network Security Group with all traffic allowed inbound
<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/2d838a58-4729-431a-880f-6f1cd83079d6" alt="before controls" width="500" height="auto">
</div>
  <details>
    <summary>JSON</summary>

        {
      "type": 3,
      "content": {
        "version": "KqlItem/1.0",
        "query": "let GeoIPDB = _GetWatchlist(\"geo_ipv4\");\nlet GeoIPDB_cities = _GetWatchlist(\"geo_ipv4_cities\");\nlet GeoIPDB_FULL = GeoIPDB | join kind = leftouter GeoIPDB_cities on geoname_id;\nlet MaliciousFlows = AzureNetworkAnalytics_CL \n| where FlowType_s == \"MaliciousFlow\"\n| order by TimeGenerated desc\n| project TimeGenerated, FlowType = FlowType_s, IpAddress = SrcIP_s, DestinationIpAddress = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRuleMatched = NSGRules_s;\nMaliciousFlows\n| evaluate ipv4_lookup(GeoIPDB_FULL, IpAddress, network)\n| project TimeGenerated, FlowType, IpAddress, DestinationIpAddress, DestinationPort, Protocol, NSGRuleMatched, latitude, longitude, subdivision = subdivision_1_name, city = city_name, country = country_name, friendly_location = strcat(city_name, \" (\", country_name, \")\")",
        "size": 3,
        "timeContext": {
          "durationMs": 2592000000
        },
        "queryType": 0,
        "resourceType": "microsoft.operationalinsights/workspaces",
        "visualization": "map",
        "mapSettings": {
          "locInfo": "LatLong",
          "locInfoColumn": "country_name",
          "latitude": "latitude",
          "longitude": "longitude",
          "sizeSettings": "city",
          "sizeAggregation": "Count",
          "opacity": 0.8,
          "labelSettings": "friendly_location",
          "legendMetric": "IpAddress",
          "legendAggregation": "Count",
          "itemColorSettings": {
            "nodeColorField": "city",
            "colorAggregation": "Count",
            "type": "heatmap",
            "heatmapPalette": "greenRed"
          }
        }
      },
      "name": "query - 0"
    }
    
  </details>









































### **Metrics Before Hardening / Security Controls**

The following table shows the metrics we measured in our insecure environment for 24 hours

| **Metric** | **Event Count** |
| --- | --- |
| **Start Time** | **2024-01-26T15:51:45.8753233Z** |
| **Stop Time** | **2024-01-27T15:51:45.8753233Z** |
| **Security Events (Windows VMs)** | **31542** |
| **Syslog (Linux VMs)** | **2325** |
| **SecurityAlert (Microsoft Defender for Cloud)** | **8** |
| **SecurityIncident (Sentinel Incidents)** | **293** |
| **NSG Inbound Malicious Flows Allowed** | **70209** |

---

# **Architecture AFTER Hardening and Implementing Security Controls**

In the "AFTER" stage of the project, I implemented a series of security controls and hardening measures to align with the **NIST SP 800-53 Rev4 SC-7(3) Access Points** standards. These enhancements significantly increased the security posture of our environment:

1. **Network Security Groups (NSGs)**: I modified NSGs to block all inbound and outbound traffic, except for specific public IP addresses that required access to the virtual machines. This approach ensured that only authorized and trusted traffic could interact with the VMs.
2. **Built-in Firewalls**: The built-in firewalls in Azure were configured on each virtual machine. This involved creating firewall rules based on each VM's specific services and responsibilities, further reducing the attack surface accessible to malicious actors.
3. **Private Endpoints**: I transitioned from Public Endpoints to Private Endpoints for Azure Key Vault and Storage Containers. This change ensured that access to these critical resources was restricted to the virtual network, isolating them from the public internet.
4. **Subnetting**: An additional layer of security was introduced by creating a dedicated subnet for Azure Key Vault and Storage Containers. This subnetting strategy further segmented network traffic to provide an extra barrier of protection and limiting potential attack vectors.

Through these bolstered security enhancements, I significantly strengthened the defense of  the virtual environment against cyber threats, demonstrating the effectiveness of a multi-layered security approach.

<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/d2c1fc65-9358-4680-99e5-53696b5c2856" alt="afterhardening" width="500" height="auto">
</div>

### **Metrics After Hardening & Implementing Security Controls**

The following table shows the metrics we measured in our environment for another 24 hours, but after we have applied security controls

| **Metric** | **Event Count** |
| --- | --- |
| Start Time | 2024-01-27T19:12:53.4053162Z |
| Stop Time | 2024-01-28T19:12:53.4053162Z |
| Security Events (Windows VMs) | 8653 |
| Syslog (Linux VMs) | 1 |
| SecurityAlert (Microsoft Defender for Cloud) | 0 |
| SecurityIncident (Sentinel Incidents) | 0 |
| NSG Inbound Malicious Flows Allowed | 0 |

### **Overall Improvement**

| **Metric** | **Change after security environment** |
| --- | --- |
| **Security Events (Windows VMs)** | -72.57% |
| **Syslog (Linux VMs)** | -99.96% |
| **SecurityAlert (Microsoft Defender for Cloud)** | -100.00% |
| **Security Incident (Sentinel Incidents)** | -100.00% |
| **NSG Inbound Malicious Flows Allowed** | -100.00% |

---

# Utilizing NIST SP 800.61 Computer Incident Handling Guide

<div style="text-align: center;">
    <img src="https://github.com/user-attachments/assets/e8566cf8-2e19-4897-9f1b-c483e6be2c48" alt="nistsp800.61" width="500" height="auto">
</div>
During each simulated attack in the project, I followed the NIST SP 800-61 guidelines for incident response. This structured approach ensured a comprehensive and effective response to each simulated cybersecurity event. The process was divided into distinct stages, each focusing on a crucial aspect of incident management:

### **Preparation**

- The Azure lab was set up to aggregate all logs into the Log Analytics Workspace. Both Microsoft Sentinel and Defender were configured with alert rules in place, setting the stage for efficient monitoring and alerting.

### **Detection & Analysis**

- Upon detecting malware on a workstation, the response involved several steps:
    - Assigning an alert owner, setting the severity to "High," and marking the status as "Active."
    - Identifying the primary user account and all affected systems.
    - Conducting a full system scan using updated antivirus software to pinpoint the malware.
    - Confirming the alert as a "True Positive."
    - Notifying the appropriate personnel in accordance with the organization's communication policies.

### **Containment, Eradication & Recovery**

- The response to the malware infection included:
    - Quarantining the infected system and any other systems impacted by the malware.
    - Shutting down and disconnecting the system from the network if malware removal or system damage was extensive.
    - Restoring affected systems to a known clean state using system images, clean OS installations, or cleaning with an up-to-date antivirus solution, depending on organizational policies.

### **Post-Incident Activity**

- Following the simulated incident:
    - An analysis was conducted to identify the root cause, which was traced to an employee downloading a game containing malware.
    - A comprehensive report was created and disseminated to all stakeholders.
    - Corrective actions were taken to address the root cause.
    - A lessons-learned review was conducted to evaluate the incident response and improve future practices.

---

# **Conclusion & Reflection**

This home-lab project involved the construction of an effective honeynet in Microsoft Azure, showcasing the critical importance of strong security measures in cloud environments. By integrating log sources into a Log Analytics workspace and employing Microsoft Sentinel to generate alerts and incidents, I gained valuable insights into the security posture of our virtual environment.

Key points from the project include:

1. **Security Measurement**: Metrics were collected both before and after implementing security controls, providing a clear comparison of the security environment's effectiveness.
2. **Effective Security Controls**: The implementation of security measures led to a drastic reduction in the number of security events and incidents, demonstrating their efficacy.
3. **Potential Impact of Regular Use**: It's important to note that if the network resources were heavily utilized by regular users, the number of security events and alerts might have increased post-implementation due to heightened activity.
4. **Adherence to Standards**: By aligning with standards such as NIST SP 800-53 r4, I significantly enhanced the security of our honeynet.
5. **Reflection and Importance of Security**: The project highlighted the essential nature of security controls and configurations in protecting resources. The comparison of metrics before and after security implementation underscored the difference between an insecure and a secure environment.

In conclusion, the project not only emphasized the importance of having proper security controls in place but also provided a practical demonstration of the transformative impact these controls can have on the security of cloud-based resources. The use of tools like Microsoft Sentinel, coupled with strategic security implementations, proved to be vital in safeguarding the environment against threats and unauthorized access.

---

# Kusto Query Language (KQL) Queries Used

<details>
    <summary>Windows Security Event Log</summary>

    // Failed Authentication (RDP, SMB)
    SecurityEvent
    | where EventID == 4625
    | where TimeGenerated > ago(15m)
    
    // Authentication Success (RDP, SMB)
    SecurityEvent
    | where EventID == 4624
    | where TimeGenerated > ago(15m)
    
    // Brute Force Attempt
    SecurityEvent
    | where EventID == 4625
    | where TimeGenerated > ago(60m)
    | summarize FailureCount = count() by SourceIP = IpAddress, EventID, Activity
    | where FailureCount >= 10
    
    // Brute Force Success Windows
    let FailedLogons = SecurityEvent
    | where EventID == 4625 and LogonType == 3
    | where TimeGenerated > ago(60m)
    | summarize FailureCount = count() by AttackerIP = IpAddress, EventID, Activity, LogonType, DestinationHostName = Computer
    | where FailureCount >= 5;
    let SuccessfulLogons = SecurityEvent
    | where EventID == 4624 and LogonType == 3
    | where TimeGenerated > ago(60m)
    | summarize SuccessfulCount = count() by AttackerIP = IpAddress, LogonType, DestinationHostName = Computer, AuthenticationSuccessTime = TimeGenerated;
    SuccessfulLogons
    | join kind = leftouter FailedLogons on DestinationHostName, AttackerIP, LogonType
    | project AuthenticationSuccessTime, AttackerIP, DestinationHostName, FailureCount, SuccessfulCount

    
  </details>

<details>
    <summary>Windows Security Event Log (Malware & Firewall)</summary>

     // Malware Detection
    Event
    | where EventLog == "Microsoft-Windows-Windows Defender/Operational"
    | where EventID == "1116" or EventID == "1117"
    
    // Firewall Tamper Detection
    Event
    | where EventLog == "Microsoft-Windows-Windows Firewall With Advanced Security/Firewall"
    | where EventID == 2003

    
  </details>

<details>
    <summary>Linux Syslog</summary>

     // Failed logon (ip address extract)
    let IpAddress_REGEX_PATTERN = @"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b";
    Syslog
    | where Facility == "auth"
    | where SyslogMessage startswith "Failed password for"
    | project TimeGenerated, SourceIP = extract(IpAddress_REGEX_PATTERN, 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type
    
    // Successful logon (ip address extract)
    let IpAddress_REGEX_PATTERN = @"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b";
    Syslog
    | where Facility == "auth"
    | where SyslogMessage startswith "Accepted password for"
    | project TimeGenerated, SourceIP = extract(IpAddress_REGEX_PATTERN, 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type
    
    // Brute Force Attempt Linux Syslog
    let IpAddress_REGEX_PATTERN = @"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b";
    Syslog
    | where Facility == "auth" and SyslogMessage startswith "Failed password for"
    | where TimeGenerated > ago(1h)
    | project TimeGenerated, AttackerIP = extract(IpAddress_REGEX_PATTERN, 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type
    | summarize FailureCount = count() by AttackerIP, DestinationHostName, DestinationIP
    | where FailureCount >= 5
    
    // Brute Force Success Linux
    let FailedLogons = Syslog
    | where Facility == "auth" and SyslogMessage startswith "Failed password for"
    | where TimeGenerated > ago(1h)
    | project TimeGenerated, SourceIP = extract(@"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b", 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type
    | summarize FailureCount = count() by AttackerIP = SourceIP, DestinationHostName
    | where FailureCount >= 5;
    let SuccessfulLogons = Syslog
    | where Facility == "auth" and SyslogMessage startswith "Accepted password for"
    | where TimeGenerated > ago(1h)
    | project TimeGenerated, SourceIP = extract(@"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b", 0, SyslogMessage), DestinationHostName = HostName, DestinationIP = HostIP, Facility, SyslogMessage, ProcessName, SeverityLevel, Type
    | summarize SuccessfulCount = count() by SuccessTime = TimeGenerated, AttackerIP = SourceIP, DestinationHostName
    | where SuccessfulCount >= 1
    | project DestinationHostName, SuccessfulCount, AttackerIP, SuccessTime;
    let BruteForceSuccesses = SuccessfulLogons
    | join kind = leftouter FailedLogons on AttackerIP, DestinationHostName;
    BruteForceSuccesses
    
    // Queries the linux syslog for any user accounts created
    // By @slendymayne (Discord)
    Syslog
    | where Facility == "authpriv" and SeverityLevel == "info"
    | where SyslogMessage contains "new user" and SyslogMessage contains "shell=/bin/bash"
    | project TimeGenerated, HostIP, HostName, ProcessID, SyslogMessage
    
    // Queries for any users given sudo privileges
    // By @slendymayne (Discord)
    Syslog
    | where Facility == "authpriv" and SeverityLevel == "info"
    | where SyslogMessage contains "to group 'sudo'"
    | project TimeGenerated, HostIP, Computer, ProcessID, SyslogMessage

  </details>

<details>
    <summary>Azure Active Directory</summary>
    
    // View Mass AAD Auth Failures
    SigninLogs
    | where ResultDescription == "Invalid username or password or Invalid on-premise username or password."
    | extend location = parse_json(LocationDetails)
    | extend City = location.city, State = location.state, Country = location.countryOrRegion, Latitude = location.geoCoordinates.latitude, Longitude = location.geoCoordinates.longitude
    | project TimeGenerated, ResultDescription, UserPrincipalName, AppDisplayName, IPAddress, IPAddressFromResourceProvider, City, State, Country, Latitude, Longitude
    
    // View Global Administrator Assignment
    AuditLogs
    | where OperationName == "Add member to role" and Result == "success"
    | where TargetResources[0].modifiedProperties[1].newValue == '"Global Administrator"' or TargetResources[0].modifiedProperties[1].newValue == '"Company Administrator"'
    | order by TimeGenerated desc
    | project TimeGenerated, OperationName, AssignedRole = TargetResources[0].modifiedProperties[1].newValue, Status = Result, TargetResources
    
    // View Password Activities
    AuditLogs
    | where OperationName contains "password"
    | order by TimeGenerated
    
    // Brute Force Success Azure Active Directory
    let FailedLogons = SigninLogs
    | where Status.failureReason == "Invalid username or password or Invalid on-premise username or password."
    | where TimeGenerated > ago(1h)
    | project TimeGenerated, Status = Status.failureReason, UserPrincipalName, UserId, UserDisplayName, AppDisplayName, AttackerIP = IPAddress, IPAddressFromResourceProvider, City = LocationDetails.city, State = LocationDetails.state, Country = LocationDetails.country, Latitude = LocationDetails.geoCoordinates.latitude, Longitude = LocationDetails.geoCoordinates.longitude
    | summarize FailureCount = count() by AttackerIP, UserPrincipalName;
    let SuccessfulLogons = SigninLogs
    | where Status.errorCode == 0
    | where TimeGenerated > ago(1h)
    | project TimeGenerated, Status = Status.errorCode, UserPrincipalName, UserId, UserDisplayName, AppDisplayName, AttackerIP = IPAddress, IPAddressFromResourceProvider, City = LocationDetails.city, State = LocationDetails.state, Country = LocationDetails.country, Latitude = LocationDetails.geoCoordinates.latitude, Longitude = LocationDetails.geoCoordinates.longitude
    | summarize SuccessCount = count() by AuthenticationSuccessTime = TimeGenerated, AttackerIP, UserPrincipalName, UserId, UserDisplayName;
    let BruteForceSuccesses = SuccessfulLogons
    | join kind = leftouter FailedLogons on AttackerIP, UserPrincipalName;
    BruteForceSuccesses
    | project AttackerIP, TargetAccount = UserPrincipalName, UserId, FailureCount, SuccessCount, AuthenticationSuccessTime
    
    // Excessive password Resets
    AuditLogs
    | where OperationName startswith "Change" or OperationName startswith "Reset"
    | order by TimeGenerated
    | summarize count() by tostring(InitiatedBy)
    | project Count = count_, InitiatorId = parse_json(InitiatedBy).user.id, InitiatorUpn = parse_json(InitiatedBy).user.userPrincipalName, InitiatorIpAddress = parse_json(InitiatedBy).user.ipAddress
    | where Count >= 10
    
  </details>

<details>
  <summary>Azure Storage Account</summary>

    // Authorization Error
    StorageBlobLogs
    | where MetricResponseType endswith "Error"
    | where StatusText == "AuthorizationPermissionMismatch"
    | order by TimeGenerated asc
    
    // Reading a bunch of blobs
    StorageBlobLogs
    | where OperationName == "GetBlob"
    
    //Deleting a bunch of blobs (in a short time period)
    StorageBlobLogs | where OperationName == "DeleteBlob"
    | where TimeGenerated > ago(24h)
    
    //Putting a bunch of blobs (in a short time period)
    StorageBlobLogs | where OperationName == "PutBlob"
    | where TimeGenerated > ago(24h)
    
    //Copying a bunch of blobs (in a short time period)
    StorageBlobLogs | where OperationName == "CopyBlob"
    | where TimeGenerated > ago(24h)

  
</details>

<details>
  <summary>Azure Key Vault</summary>
    
    // List out Secrets
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretList"
    
    // Attempt to view passwords that don't exist
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretGet"
    | where ResultSignature == "Not Found"
    
    // Viewing an actual existing password
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretGet"
    | where ResultSignature == "OK"
    
    // Viewing a specific existing password
    let CRITICAL_PASSWORD_NAME = "Tenant-Global-Admin-Password";
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretGet"
    | where id_s contains CRITICAL_PASSWORD_NAME
    
    // Updating a password Success
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretSet"
    
    // Updating a specific existing password Success
    let CRITICAL_PASSWORD_NAME = "Tenant-Global-Admin-Password";
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretSet"
    | where id_s endswith CRITICAL_PASSWORD_NAME
    | where TimeGenerated > ago(2h)
    
    // Failed access attempts
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where ResultSignature == "Unauthorized"
    
    // Updating a specific existing secret in Key Vault
    let CRITICAL_PASSWORD_NAME = "Tenant-Global-Admin-Password";
    AzureDiagnostics
    | where ResourceProvider == "MICROSOFT.KEYVAULT"
    | where OperationName == "SecretSet"
    | where id_s endswith CRITICAL_PASSWORD_NAME

</details>

<details>
  <summary>Network Security Groups</summary>

    // Allowed inbound malicious flows
    AzureNetworkAnalytics_CL
    | where FlowType_s == "MaliciousFlow" and AllowedInFlows_d >= 1
    | project TimeGenerated, FlowType = FlowType_s, IpAddress = SrcIP_s, DestinationIpAddress = DestIP_s, DestinationPort = DestPort_d, Protocol = L7Protocol_s, NSGRuleMatched = NSGRules_s, InboundFlowCount = AllowedInFlows_d

</details>
